<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">



  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.jpg?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.jpg?v=6.4.2">


  <link rel="mask-icon" href="/images/favicon.jpg?v=6.4.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.4.2',
    sidebar: {"position":"left","width":280,"display":"always","offset":25,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Flink组件栈Flink 采用分层的架构设计，从而保证各层在功能和职责上的清晰。如下图所示，由上而下分别是 API &amp;amp; Libraries 层、Runtime 核心层以及物理部署层：  API &amp;amp; Libraries 层这一层主要提供了编程 API 和 顶层类库：  编程 API : 用于进行流处理的 DataStream API 和用于进行批处理的 DataSet API； 顶">
<meta name="keywords" content="总结">
<meta property="og:type" content="article">
<meta property="og:title" content="Flink 总结">
<meta property="og:url" content="http://blog.kyleliu.cn/2020/04/28/21.总结/Flink/index.html">
<meta property="og:site_name" content="刘小恺(Kyle) 的云笔记">
<meta property="og:description" content="Flink组件栈Flink 采用分层的架构设计，从而保证各层在功能和职责上的清晰。如下图所示，由上而下分别是 API &amp;amp; Libraries 层、Runtime 核心层以及物理部署层：  API &amp;amp; Libraries 层这一层主要提供了编程 API 和 顶层类库：  编程 API : 用于进行流处理的 DataStream API 和用于进行批处理的 DataSet API； 顶">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586404760423.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586489584052.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586404927178.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586410450743.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586410843615.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586410901685.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586411714405.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586411745166.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586489825589.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586415778743.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586421691428.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586424744865.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586425914911.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586425957804.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586422308463.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586422565315.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586423597586.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586424315574.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586577084774.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586589440002.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586589447529.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586589616212.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586590446371.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586590568191.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586591065285.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586591258097.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586583564019.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586583578404.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586583590046.png">
<meta property="og:image" content="http://blog.kyleliu.cn/source/img/1586584999171.png">
<meta property="og:updated_time" content="2020-04-29T16:19:05.730Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Flink 总结">
<meta name="twitter:description" content="Flink组件栈Flink 采用分层的架构设计，从而保证各层在功能和职责上的清晰。如下图所示，由上而下分别是 API &amp;amp; Libraries 层、Runtime 核心层以及物理部署层：  API &amp;amp; Libraries 层这一层主要提供了编程 API 和 顶层类库：  编程 API : 用于进行流处理的 DataStream API 和用于进行批处理的 DataSet API； 顶">
<meta name="twitter:image" content="http://blog.kyleliu.cn/source/img/1586404760423.png">






  <link rel="canonical" href="http://blog.kyleliu.cn/2020/04/28/21.总结/Flink/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Flink 总结 | 刘小恺(Kyle) 的云笔记</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?61af49e7933cbd35801eb5e4ca789a8d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">刘小恺(Kyle) 的云笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">Python 、Machine learning 、Docker k8s  crawler 、Golang 、Web</h1>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  
    <div class="reading-progress-bar"></div>
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.kyleliu.cn/2020/04/28/21.总结/Flink/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘小恺(Kyle)">
      <meta itemprop="description" content="Python 、Machine learning 、Docker k8s  crawler 、Golang 、Web">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘小恺(Kyle) 的云笔记">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Flink 总结
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-04-28 13:43:11" itemprop="dateCreated datePublished" datetime="2020-04-28T13:43:11+08:00">2020-04-28</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/总结/" itemprop="url" rel="index"><span itemprop="name">总结</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/28/21.总结/Flink/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2020/04/28/21.总结/Flink/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="Flink组件栈"><a href="#Flink组件栈" class="headerlink" title="Flink组件栈"></a>Flink组件栈</h3><p>Flink 采用分层的架构设计，从而保证各层在功能和职责上的清晰。如下图所示，由上而下分别是 API &amp; Libraries 层、Runtime 核心层以及物理部署层：</p>
<p><img src="/source/img/1586404760423.png" alt="1586404760423"></p>
<h4 id="API-amp-Libraries-层"><a href="#API-amp-Libraries-层" class="headerlink" title="API &amp; Libraries 层"></a>API &amp; Libraries 层</h4><p>这一层主要提供了编程 API 和 顶层类库：</p>
<ul>
<li>编程 API : 用于进行流处理的 DataStream API 和用于进行批处理的 DataSet API；</li>
<li>顶层类库：包括用于复杂事件处理的 CEP 库；用于结构化数据查询的 SQL &amp; Table 库，以及基于批处理的机器学习库 FlinkML 和 图形处理库 Gelly。</li>
</ul>
<h4 id="Runtime-核心层"><a href="#Runtime-核心层" class="headerlink" title="Runtime 核心层"></a>Runtime 核心层</h4><p>这一层是 Flink 分布式计算框架的核心实现层，包括作业转换，任务调度，资源分配，任务执行等功能，基于这一层的实现，可以在流式引擎下同时运行流处理程序和批处理程序。比如：支持分布式Stream处理、JobGraph到ExecutionGraph的映射、调度等等，为上层API层提供基础服务</p>
<h4 id="物理部署层"><a href="#物理部署层" class="headerlink" title="物理部署层"></a>物理部署层</h4><p>Flink 的物理部署层，用于支持在不同平台上部署运行 Flink 应用。</p>
<p>主要涉及了Flink的部署模式，Flink支持多种部署模式：本地、集群（Standalone/YARN）、云（GCE/EC2）</p>
<p><img src="/source/img/1586489584052.png" alt="1586489584052"></p>
<h3 id="Flink-分层-API"><a href="#Flink-分层-API" class="headerlink" title="Flink 分层 API"></a>Flink 分层 API</h3><p>在上面介绍的 API &amp; Libraries 这一层，Flink 又进行了更为具体的划分。具体如下：</p>
<p><img src="/source/img/1586404927178.png" alt="1586404927178"></p>
<p>按照如上的层次结构，API 的一致性由下至上依次递增，接口的表现能力由下至上依次递减，各层的核心功能如下：</p>
<h4 id="SQL-amp-Table-API"><a href="#SQL-amp-Table-API" class="headerlink" title="SQL &amp; Table API"></a>SQL &amp; Table API</h4><p>SQL &amp; Table API 同时适用于批处理和流处理，这意味着你可以对有界数据流和无界数据流以相同的语义进行查询，并产生相同的结果。除了基本查询外， 它还支持自定义的标量函数，聚合函数以及表值函数，可以满足多样化的查询需求。 </p>
<h4 id="DataStream-amp-DataSet-API"><a href="#DataStream-amp-DataSet-API" class="headerlink" title="DataStream &amp; DataSet API"></a>DataStream &amp; DataSet API</h4><p>DataStream &amp;  DataSet API 是 Flink 数据处理的核心 API，支持使用 Java 语言或 Scala 语言进行调用，提供了数据读取，数据转换和数据输出等一系列常用操作的封装。</p>
<h4 id="Stateful-Stream-Processing"><a href="#Stateful-Stream-Processing" class="headerlink" title="Stateful Stream Processing"></a>Stateful Stream Processing</h4><p>Stateful Stream Processing 是最低级别的抽象，它通过 Process Function 函数内嵌到 DataStream API 中。 Process Function 是 Flink 提供的最底层 API，具有最大的灵活性，允许开发者对于时间和状态进行细粒度的控制。</p>
<h3 id="Flink-集群架构"><a href="#Flink-集群架构" class="headerlink" title="Flink 集群架构"></a>Flink 集群架构</h3><h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><p>按照上面的介绍，Flink 核心架构的第二层是 Runtime 层， 该层采用标准的 Master - Slave 结构， 其中，Master 部分又包含了三个核心组件：Dispatcher、ResourceManager 和 JobManager，而 Slave 则主要是 TaskManager 进程。它们的功能分别如下：</p>
<ul>
<li><p><strong>Client</strong>： 用户提交一个Flink程序时，会首先创建一个Client，该Client首先会对用户提交的Flink程序进行预处理，并提交到Flink集群， Client会将用户提交的Flink程序组装一个JobGraph， 并且是以JobGraph的形式提交的</p>
</li>
<li><p><strong>Dispatcher</strong>：负责接收客户端提交的执行程序，并传递给 JobManager 。除此之外，它还提供了一个 WEB UI 界面，用于监控作业的执行情况。</p>
</li>
<li><p><strong>JobManagers</strong> (也称为 <em>masters</em>) ：JobManagers 接收由 Dispatcher 传递过来的执行程序，该执行程序包含了作业图 (JobGraph)，逻辑数据流图 (logical dataflow graph) 及其所有的 classes 文件以及第三方类库 (libraries) 等等 。紧接着 JobManagers 会将 JobGraph 转换为执行图 (ExecutionGraph)，然后向 ResourceManager 申请资源来执行该任务，一旦申请到资源，就将执行图分发给对应的 TaskManagers 。因此每个作业 (Job) 至少有一个 JobManager；高可用部署下可以有多个 JobManagers，其中一个作为 <em>leader</em>，其余的则处于 <em>standby</em> 状态。</p>
</li>
<li><p><strong>ResourceManager</strong> ：负责管理 slots 并协调集群资源。ResourceManager 接收来自 JobManager 的资源请求，并将存在空闲 slots 的 TaskManagers 分配给 JobManager 执行任务。Flink 基于不同的部署平台，如 YARN , Mesos，K8s 等提供了不同的资源管理器，当 TaskManagers 没有足够的 slots 来执行任务时，它会向第三方平台发起会话来请求额外的资源。</p>
</li>
<li><p><strong>TaskManagers</strong> (也称为 <em>workers</em>) : TaskManagers 负责实际的子任务 (subtasks) 的执行，每个 TaskManagers 都拥有一定数量的 slots。Slot 是一组固定大小的资源的合集 (如计算能力，存储空间)。TaskManagers 启动后，会将其所拥有的 slots 注册到 ResourceManager 上，由 ResourceManager 进行统一管理。</p>
</li>
</ul>
<p><img src="/source/img/1586410450743.png" alt="1586410450743"></p>
<h4 id="Task-amp-SubTask"><a href="#Task-amp-SubTask" class="headerlink" title="Task &amp; SubTask"></a>Task &amp; SubTask</h4><p>上面我们提到：TaskManagers 实际执行的是 SubTask，而不是 Task，这里解释一下两者的区别：</p>
<p>在执行分布式计算时，Flink 将可以链接的操作 (operators) 链接到一起，这就是 Task。之所以这样做， 是为了减少线程间切换和缓冲而导致的开销，在降低延迟的同时可以提高整体的吞吐量。 但不是所有的 operator 都可以被链接，如下 keyBy 等操作会导致网络 shuffle 和重分区，因此其就不能被链接，只能被单独作为一个 Task。  简单来说，一个 Task 就是一个可以链接的最小的操作链 (Operator Chains) 。如下图，source 和 map 算子被链接到一块，因此整个作业就只有三个 Task：</p>
<p><img src="/source/img/1586410843615.png" alt="1586410843615"></p>
<p>解释完 Task ，我们在解释一下什么是 SubTask，其准确的翻译是： <em>A subtask is one parallel slice of a task</em>，即一个 Task 可以按照其并行度拆分为多个 SubTask。如上图，source &amp; map 具有两个并行度，KeyBy 具有两个并行度，Sink 具有一个并行度，因此整个虽然只有 3 个 Task，但是却有 5 个 SubTask。Jobmanager 负责定义和拆分这些 SubTask，并将其交给 Taskmanagers 来执行，每个 SubTask 都是一个单独的线程。</p>
<h4 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h4><p>理解了 SubTasks ，我们再来看看其与 Slots 的对应情况。一种可能的分配情况如下：</p>
<p><img src="/source/img/1586410901685.png" alt="1586410901685"></p>
<p>这时每个 SubTask 线程运行在一个独立的 TaskSlot， 它们共享所属的 TaskManager 进程的TCP 连接（通过多路复用技术）和心跳信息 (heartbeat messages)，从而可以降低整体的性能开销。此时看似是最好的情况，但是每个操作需要的资源都是不尽相同的，这里假设该作业 keyBy 操作所需资源的数量比 Sink 多很多 ，那么此时 Sink 所在 Slot 的资源就没有得到有效的利用。</p>
<p>基于这个原因，Flink 允许多个 subtasks 共享 slots，即使它们是不同 tasks 的 subtasks，但只要它们来自同一个 Job 就可以。假设上面 souce &amp; map 和 keyBy 的并行度调整为 6，而 Slot 的数量不变，此时情况如下：</p>
<p><img src="/source/img/1586411714405.png" alt="1586411714405"></p>
<p>可以看到一个 Task Slot 中运行了多个 SubTask 子任务，此时每个子任务仍然在一个独立的线程中执行，只不过共享一组 Sot 资源而已。那么 Flink 到底如何确定一个 Job 至少需要多少个 Slot 呢？Flink 对于这个问题的处理很简单，默认情况一个 Job 所需要的 Slot 的数量就等于其 Operation 操作的最高并行度。如下， A，B，D 操作的并行度为 4，而 C，E 操作的并行度为 2，那么此时整个 Job 就需要至少四个 Slots 来完成。通过这个机制，Flink 就可以不必去关心一个 Job 到底会被拆分为多少个 Tasks 和 SubTasks。</p>
<p><img src="/source/img/1586411745166.png" alt="1586411745166"></p>
<h3 id="Flink-优势"><a href="#Flink-优势" class="headerlink" title="Flink 优势"></a>Flink 优势</h3><ul>
<li>支持高吞吐、低延迟、高性能的流处理</li>
<li>支持高度灵活的窗口（Window）操作</li>
<li>支持有状态计算的Exactly-once语义</li>
<li>提供DataStream API和DataSet API</li>
</ul>
<p><img src="/source/img/1586489825589.png" alt="1586489825589"></p>
<h3 id="Source-和-sink"><a href="#Source-和-sink" class="headerlink" title="Source 和 sink"></a>Source 和 sink</h3><h4 id="自定义-Data-Source"><a href="#自定义-Data-Source" class="headerlink" title="自定义 Data Source"></a>自定义 Data Source</h4><p><strong>SourceFunction</strong></p>
<p>除了内置的数据源外，用户还可以使用 <code>addSource</code> 方法来添加自定义的数据源。自定义的数据源必须要实现 SourceFunction 接口，这里以产生 [0 , 1000) 区间内的数据为例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">env.addSource(<span class="keyword">new</span> SourceFunction&lt;Long&gt;() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isRunning = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext&lt;Long&gt; ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (isRunning &amp;&amp; count &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过collect将输入发送出去 </span></span><br><span class="line">            ctx.collect(count);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isRunning = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;).print();</span><br><span class="line">env.execute();</span><br></pre></td></tr></table></figure>

<h4 id="ParallelSourceFunction-和-RichParallelSourceFunction"><a href="#ParallelSourceFunction-和-RichParallelSourceFunction" class="headerlink" title="ParallelSourceFunction 和 RichParallelSourceFunction"></a>ParallelSourceFunction 和 RichParallelSourceFunction</h4><p>上面通过 SourceFunction 实现的数据源是不具有并行度的，即不支持在得到的 DataStream 上调用 <code>setParallelism(n)</code> 方法，此时会抛出如下的异常：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread "main" java.lang.IllegalArgumentException: Source: 1 is not a parallel source</span><br></pre></td></tr></table></figure>

<p>如果你想要实现具有并行度的输入流，则需要实现 ParallelSourceFunction 或 RichParallelSourceFunction 接口，其与 SourceFunction 的关系如下图： </p>
<p><img src="/source/img/1586415778743.png" alt="1586415778743"></p>
<p>ParallelSourceFunction 直接继承自 ParallelSourceFunction，具有并行度的功能。RichParallelSourceFunction 则继承自 AbstractRichFunction，同时实现了 ParallelSourceFunction 接口，所以其除了具有并行度的功能外，还提供了额外的与生命周期相关的方法，如 open() ，closen() 。</p>
<h4 id="自定义-Sink"><a href="#自定义-Sink" class="headerlink" title="自定义 Sink"></a>自定义 Sink</h4><p>除了使用内置的第三方连接器外，Flink 还支持使用自定义的 Sink 来满足多样化的输出需求。想要实现自定义的 Sink ，需要直接或者间接实现 SinkFunction 接口。通常情况下，我们都是实现其抽象类 RichSinkFunction，相比于 SinkFunction ，其提供了更多的与生命周期相关的方法。两者间的关系如下：</p>
<p> <img src="/source/img/1586421691428.png" alt="1586421691428"></p>
<p>这里我们以自定义一个 FlinkToMySQLSink 为例，将计算结果写出到 MySQL 数据库中，具体步骤如下：</p>
<h5 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h5><p>首先需要导入 MySQL 相关的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="自定义-Sink-1"><a href="#自定义-Sink-1" class="headerlink" title="自定义 Sink"></a>自定义 Sink</h5><p>继承自 RichSinkFunction，实现自定义的 Sink ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlinkToMySQLSink</span> <span class="keyword">extends</span> <span class="title">RichSinkFunction</span>&lt;<span class="title">Employee</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PreparedStatement stmt;</span><br><span class="line">    <span class="keyword">private</span> Connection conn;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class.forName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">        conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://192.168.0.229:3306/employees"</span> +</span><br><span class="line">                                           <span class="string">"?characterEncoding=UTF-8&amp;serverTimezone=UTC&amp;useSSL=false"</span>, </span><br><span class="line">                                           <span class="string">"root"</span>, </span><br><span class="line">                                           <span class="string">"123456"</span>);</span><br><span class="line">        String sql = <span class="string">"insert into emp(name, age, birthday) values(?, ?, ?)"</span>;</span><br><span class="line">        stmt = conn.prepareStatement(sql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Employee value, Context context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        stmt.setString(<span class="number">1</span>, value.getName());</span><br><span class="line">        stmt.setInt(<span class="number">2</span>, value.getAge());</span><br><span class="line">        stmt.setDate(<span class="number">3</span>, value.getBirthday());</span><br><span class="line">        stmt.executeUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.close();</span><br><span class="line">        <span class="keyword">if</span> (stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stmt.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用自定义-Sink"><a href="#使用自定义-Sink" class="headerlink" title="使用自定义 Sink"></a>使用自定义 Sink</h5><p>想要使用自定义的 Sink，同样是需要调用 addSink 方法，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">Date date = <span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line">DataStreamSource&lt;Employee&gt; streamSource = env.fromElements(</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="string">"hei"</span>, <span class="number">10</span>, date),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="string">"bai"</span>, <span class="number">20</span>, date),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="string">"ying"</span>, <span class="number">30</span>, date));</span><br><span class="line">streamSource.addSink(<span class="keyword">new</span> FlinkToMySQLSink());</span><br><span class="line">env.execute();</span><br></pre></td></tr></table></figure>

<h4 id="Streaming-Connectors"><a href="#Streaming-Connectors" class="headerlink" title="Streaming Connectors"></a>Streaming Connectors</h4><h5 id="内置连接器"><a href="#内置连接器" class="headerlink" title="内置连接器"></a>内置连接器</h5><p>除了自定义数据源外， Flink 还内置了多种连接器，用于满足大多数的数据收集场景。当前内置连接器的支持情况如下：</p>
<ul>
<li>Apache Kafka (支持 source 和 sink)</li>
<li>Apache Cassandra (sink)</li>
<li>Amazon Kinesis Streams (source/sink)</li>
<li>Elasticsearch (sink)</li>
<li>Hadoop FileSystem (sink)</li>
<li>RabbitMQ (source/sink)</li>
<li>Apache NiFi (source/sink)</li>
<li>Twitter Streaming API (source)</li>
<li>Google PubSub (source/sink)</li>
</ul>
<p>除了上述的连接器外，你还可以通过 Apache Bahir 的连接器扩展 Flink。Apache Bahir 旨在为分布式数据分析系统 (如 Spark，Flink) 等提供功能上的扩展，当前其支持的与 Flink 相关的连接器如下：</p>
<ul>
<li>Apache ActiveMQ (source/sink)</li>
<li>Apache Flume (sink)</li>
<li>Redis (sink)</li>
<li>Akka (sink)</li>
<li>Netty (source)</li>
</ul>
<h3 id="Flink-状态"><a href="#Flink-状态" class="headerlink" title="Flink 状态"></a>Flink 状态</h3><p>相对于其他流计算框架，Flink 一个比较重要的特性就是其支持有状态计算。即你可以将中间的计算结果进行保存，并提供给后续的计算使用：</p>
<p><img src="/source/img/1586424744865.png" alt="1586424744865"></p>
<p>具体而言，Flink 又将状态 (State) 分为 Keyed State 与 Operator State：</p>
<h4 id="算子状态"><a href="#算子状态" class="headerlink" title="算子状态"></a>算子状态</h4><p>算子状态 (Operator State)：顾名思义，状态是和算子进行绑定的，一个算子的状态不能被其他算子所访问到。官方文档上对 Operator State 的解释是：<em>each operator state is bound to one parallel operator instance</em>，所以更为确切的说一个算子状态是与一个并发的算子实例所绑定的，即假设算子的并行度是 2，那么其应有两个对应的算子状态：</p>
<p><img src="/source/img/1586425914911.png" alt="1586425914911"></p>
<h4 id="键控状态"><a href="#键控状态" class="headerlink" title="键控状态"></a>键控状态</h4><p>键控状态 (Keyed State) ：是一种特殊的算子状态，即状态是根据 key 值进行区分的，Flink 会为每类键值维护一个状态实例。如下图所示，每个颜色代表不同 key 值，对应四个不同的状态实例。需要注意的是键控状态只能在 <code>KeyedStream</code> 上进行使用，我们可以通过 <code>stream.keyBy(...)</code> 来得到 <code>KeyedStream</code> 。</p>
<p><img src="/source/img/1586425957804.png" alt="1586425957804"></p>
<h3 id="检查点机制"><a href="#检查点机制" class="headerlink" title="检查点机制"></a>检查点机制</h3><h4 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h4><p>为了使 Flink 的状态具有良好的容错性，Flink 提供了检查点机制 (CheckPoints)  。通过检查点机制，Flink 定期在数据流上生成 checkpoint barrier ，当某个算子收到 barrier 时，即会基于当前状态生成一份快照，然后再将该 barrier 传递到下游算子，下游算子接收到该 barrier 后，也基于当前状态生成一份快照，依次传递直至到最后的 Sink 算子上。当出现异常后，Flink 就可以根据最近的一次的快照数据将所有算子恢复到先前的状态。</p>
<h4 id="开启检查点"><a href="#开启检查点" class="headerlink" title="开启检查点"></a>开启检查点</h4><p>默认情况下，检查点机制是关闭的，需要在程序中进行开启：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启检查点机制，并指定状态检查点之间的时间间隔</span></span><br><span class="line">env.enableCheckpointing(<span class="number">1000</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他可选配置如下：</span></span><br><span class="line"><span class="comment">// 设置语义</span></span><br><span class="line">env.getCheckpointConfig().setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);</span><br><span class="line"><span class="comment">// 设置两个检查点之间的最小时间间隔</span></span><br><span class="line">env.getCheckpointConfig().setMinPauseBetweenCheckpoints(<span class="number">500</span>);</span><br><span class="line"><span class="comment">// 设置执行Checkpoint操作时的超时时间</span></span><br><span class="line">env.getCheckpointConfig().setCheckpointTimeout(<span class="number">60000</span>);</span><br><span class="line"><span class="comment">// 设置最大并发执行的检查点的数量</span></span><br><span class="line">env.getCheckpointConfig().setMaxConcurrentCheckpoints(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 将检查点持久化到外部存储</span></span><br><span class="line">env.getCheckpointConfig().enableExternalizedCheckpoints(</span><br><span class="line">    ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION);</span><br><span class="line"><span class="comment">// 如果有更近的保存点时，是否将作业回退到该检查点</span></span><br><span class="line">env.getCheckpointConfig().setPreferCheckpointForRecovery(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<h3 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h3><h4 id="Tumbling-Windows"><a href="#Tumbling-Windows" class="headerlink" title="Tumbling Windows"></a>Tumbling Windows</h4><p>滚动窗口 (Tumbling Windows) 是指彼此之间没有重叠的窗口。例如：每隔1小时统计过去1小时内的商品点击量，那么 1 天就只能分为 24 个窗口，每个窗口彼此之间是不存在重叠的，具体如下：</p>
<p><img src="/source/img/1586422308463.png" alt="1586422308463"></p>
<ol>
<li><p>这里我们以词频统计为例，给出一个具体的用例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"><span class="comment">// 接收socket上的数据输入</span></span><br><span class="line">DataStreamSource&lt;String&gt; streamSource = env.socketTextStream(<span class="string">"hadoop001"</span>, <span class="number">9999</span>, <span class="string">"\n"</span>, <span class="number">3</span>);</span><br><span class="line">streamSource.flatMap(<span class="keyword">new</span> FlatMapFunction&lt;String, Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String value, Collector&lt;Tuple2&lt;String, Long&gt;&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String[] words = value.split(<span class="string">"\t"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            out.collect(<span class="keyword">new</span> Tuple2&lt;&gt;(word, <span class="number">1L</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).keyBy(<span class="number">0</span>).timeWindow(Time.seconds(<span class="number">3</span>)).sum(<span class="number">1</span>).print(); <span class="comment">//每隔3秒统计一次每个单词出现的数量</span></span><br><span class="line">env.execute(<span class="string">"Flink Streaming"</span>);</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
</li>
<li><p>假如我们需要统计每一分钟中用户购买的商品的总数，需要将用户的行为事件按每一分钟进行切分，这种切分被成为翻滚时间窗口（Tumbling Time Window）。翻滚窗口能将数据流切分成不重叠的窗口，每一个事件只能属于一个窗口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户id和购买数量 stream</span></span><br><span class="line">val counts: DataStream[(Int, Int)] = ...</span><br><span class="line">val tumblingCnts: DataStream[(Int, Int)] = counts</span><br><span class="line">  <span class="comment">// 用userId分组</span></span><br><span class="line">  .keyBy(<span class="number">0</span>) </span><br><span class="line">  <span class="comment">// 1分钟的翻滚窗口宽度</span></span><br><span class="line">  .timeWindow(Time.minutes(<span class="number">1</span>))</span><br><span class="line">  <span class="comment">// 计算购买数量</span></span><br><span class="line">  .sum(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="Sliding-Windows"><a href="#Sliding-Windows" class="headerlink" title="Sliding Windows"></a>Sliding Windows</h4><p>滑动窗口用于滚动进行聚合分析，例如：每隔 6 分钟统计一次过去一小时内所有商品的点击量，那么统计窗口彼此之间就是存在重叠的，即 1天可以分为 240 个窗口。图示如下：</p>
<p><img src="/source/img/1586422565315.png" alt="1586422565315"></p>
<p>可以看到 window 1 - 4 这四个窗口彼此之间都存在着时间相等的重叠部分。想要实现滑动窗口，只需要在使用 timeWindow 方法时额外传递第二个参数作为滚动时间即可，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每隔3秒统计一次过去1分钟内的数据</span></span><br><span class="line">keyBy(<span class="number">0</span>).timeWindow(Time.minutes(<span class="number">1</span>),Time.seconds(<span class="number">3</span>)).sum(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Session-Windows"><a href="#Session-Windows" class="headerlink" title="Session Windows"></a>Session Windows</h4><p>当用户在进行持续浏览时，可能每时每刻都会有点击数据，例如在活动区间内，用户可能频繁的将某类商品加入和移除购物车，而你只想知道用户本次浏览最终的购物车情况，此时就可以在用户持有的会话结束后再进行统计。想要实现这类统计，可以通过 Session Windows 来进行实现。</p>
<p><img src="/source/img/1586423597586.png" alt="1586423597586"></p>
<p>具体的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以处理时间为衡量标准，如果10秒内没有任何数据输入，就认为会话已经关闭，此时触发统计</span></span><br><span class="line">window(ProcessingTimeSessionWindows.withGap(Time.seconds(<span class="number">10</span>)))</span><br><span class="line"><span class="comment">// 以事件时间为衡量标准    </span></span><br><span class="line">window(EventTimeSessionWindows.withGap(Time.seconds(<span class="number">10</span>)))</span><br></pre></td></tr></table></figure>

<h4 id="Global-Windows"><a href="#Global-Windows" class="headerlink" title="Global Windows"></a>Global Windows</h4><p>最后一个窗口是全局窗口， 全局窗口会将所有 key 相同的元素分配到同一个窗口中，其通常配合触发器 (trigger) 进行使用。如果没有相应触发器，则计算将不会被执行。</p>
<p><img src="/source/img/1586424315574.png" alt="1586424315574"></p>
<p>这里继续以上面词频统计的案例为例，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当单词累计出现的次数每达到10次时，则触发计算，计算整个窗口内该单词出现的总数</span></span><br><span class="line">window(GlobalWindows.create()).trigger(CountTrigger.of(<span class="number">10</span>)).sum(<span class="number">1</span>).print();</span><br></pre></td></tr></table></figure>

<h4 id="Count-Windows"><a href="#Count-Windows" class="headerlink" title="Count Windows"></a>Count Windows</h4><p>Count Windows 用于以数量为维度来进行数据聚合，同样也分为滚动窗口和滑动窗口，实现方式也和时间窗口完全一致，只是调用的 API 不同，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动计数窗口，每1000次点击则计算一次</span></span><br><span class="line">countWindow(<span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 滑动计数窗口，每10次点击发生后，则计算过去1000次点击的情况</span></span><br><span class="line">countWindow(<span class="number">1000</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>实际上计数窗口内部就是调用的我们上一部分介绍的全局窗口来实现的，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WindowedStream&lt;T, KEY, GlobalWindow&gt; <span class="title">countWindow</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> window(GlobalWindows.create()).trigger(PurgingTrigger.of(CountTrigger.of(size)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowedStream&lt;T, KEY, GlobalWindow&gt; <span class="title">countWindow</span><span class="params">(<span class="keyword">long</span> size, <span class="keyword">long</span> slide)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> window(GlobalWindows.create())</span><br><span class="line">        .evictor(CountEvictor.of(size))</span><br><span class="line">        .trigger(CountTrigger.of(slide));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间（Time）"><a href="#时间（Time）" class="headerlink" title="时间（Time）"></a>时间（Time）</h3><h4 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h4><ul>
<li>Flink中的时间与现实世界中的时间是不一致的，在flink中被划分为<strong>事件时间，摄入时间，处理时间</strong>三种。</li>
<li>如果以EventTime为基准来定义时间窗口将形成EventTimeWindow,要求消息本身就应该携带EventTime</li>
<li>如果以IngesingtTime为基准来定义时间窗口将形成IngestingTimeWindow,以source的systemTime为准。</li>
<li>如果以ProcessingTime基准来定义时间窗口将形成ProcessingTimeWindow，以operator的systemTime为准。</li>
</ul>
<p><img src="/source/img/1586577084774.png" alt="1586577084774"></p>
<h4 id="时间详解"><a href="#时间详解" class="headerlink" title="时间详解"></a>时间详解</h4><p><strong>Processing Time</strong></p>
<p>Processing Time 是指事件被处理时机器的系统时间。</p>
<p><strong>Event Time</strong></p>
<p>Event Time 是事件发生的时间，一般就是数据本身携带的时间。这个时间通常是在事件到达 Flink 之前就确定的，并且可以从每个事件中获取到事件时间戳。在 Event Time 中，时间取决于数据，而跟其他没什么关系。Event Time 程序必须指定如何生成 Event Time 水印，这是表示 Event Time 进度的机制。</p>
<p><strong>Ingestion Time</strong></p>
<p>Ingestion Time 是事件进入 Flink 的时间。 在源操作处，每个事件将源的当前时间作为时间戳，并且基于时间的操作（如时间窗口）会利用这个时间戳。</p>
<h4 id="时间乱序存在的问题"><a href="#时间乱序存在的问题" class="headerlink" title="时间乱序存在的问题"></a>时间乱序存在的问题</h4><p>在介绍Watermark相关内容之前我们先抛出一个具体的问题，在实际的流式计算中数据到来的顺序对计算结果的正确性有至关重要的影响，比如：某数据源中的某些数据由于某种原因(如：网络原因，外部存储自身原因)会有5秒的延时，也就是在实际时间的第1秒产生的数据有可能在第5秒中产生的数据之后到来(比如到Window处理节点).选具体某个delay的元素来说，假设在一个5秒的Tumble窗口(详见Window介绍章节)，有一个EventTime是 11秒的数据，在第16秒时候到来了。图示第11秒的数据，在16秒到来了，如下图：</p>
<p><img src="/source/img/1586589440002.png" alt="1586589440002"></p>
<p>那么对于一个Count聚合的Tumble(5s)的window，上面的情况如何处理才能window2=4，window3=2 呢？Apache Flink的时间类型<br>开篇我们描述的问题是一个很常见的TimeWindow中数据乱序的问题，乱序是相对于事件产生时间和到达Apache Flink 实际处理算子的顺序而言的，关于时间在Apache Flink中有如下三种时间类型，如下图：</p>
<p><img src="/source/img/1586589447529.png" alt="1586589447529"></p>
<p>那么对于一个Count聚合的Tumble(5s)的window，上面的情况如何处理才能window2=4，window3=2 呢？</p>
<h4 id="什么是Watermark"><a href="#什么是Watermark" class="headerlink" title="什么是Watermark"></a>什么是Watermark</h4><p>Watermark是Apache Flink为了处理EventTime 窗口计算提出的一种机制,本质上也是一种时间戳，由Apache Flink Source或者自定义的Watermark生成器按照需求Punctuated或者Periodic两种方式生成的一种系统Event，与普通数据流Event一样流转到对应的下游算子，接收到Watermark Event的算子以此不断调整自己管理的EventTime clock。 Apache Flink 框架保证Watermark单调递增，算子接收到一个Watermark时候，框架知道不会再有任何小于该Watermark的时间戳的数据元素到来了，所以Watermark可以看做是告诉Apache Flink框架数据流已经处理到什么位置(时间维度)的方式。 Watermark的产生和Apache Flink内部处理逻辑如下图所示: </p>
<p><img src="/source/img/1586589616212.png" alt="1586589616212"></p>
<h4 id="Watermark的产生方式"><a href="#Watermark的产生方式" class="headerlink" title="Watermark的产生方式"></a>Watermark的产生方式</h4><p>目前Apache Flink 有两种生产Watermark的方式，如下：</p>
<ul>
<li>Punctuated - 数据流中每一个递增的EventTime都会产生一个Watermark。 </li>
</ul>
<p>在实际的生产中Punctuated方式在TPS很高的场景下会产生大量的Watermark在一定程度上对下游算子造成压力，所以只有在实时性要求非常高的场景才会选择Punctuated的方式进行Watermark的生成。</p>
<ul>
<li>Periodic - 周期性的（一定时间间隔或者达到一定的记录条数）产生一个Watermark。在实际的生产中Periodic的方式必须结合时间和积累条数两个维度继续周期性产生Watermark，否则在极端情况下会有很大的延时。</li>
</ul>
<p>所以Watermark的生成方式需要根据业务场景的不同进行不同的选择。</p>
<h4 id="Watermark的接口定义"><a href="#Watermark的接口定义" class="headerlink" title="Watermark的接口定义"></a>Watermark的接口定义</h4><p>对应Apache Flink Watermark两种不同的生成方式，我们了解一下对应的接口定义，如下：</p>
<ul>
<li>Periodic Watermarks - AssignerWithPeriodicWatermarks</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Returns the current watermark. This method is periodically called by the</span><br><span class="line">* system to retrieve the current watermark. The method may return &#123;@code null&#125; to</span><br><span class="line">* indicate that no new Watermark is available.</span><br><span class="line">*</span><br><span class="line">* The returned watermark will be emitted only if it is non-null and itsTimestamp</span><br><span class="line">* is larger than that of the previously emitted watermark (to preserve the contract of</span><br><span class="line">* ascending watermarks). If the current watermark is still</span><br><span class="line">* identical to the previous one, no progress in EventTime has happened since</span><br><span class="line">* the previous call to this method. If a null value is returned, or theTimestamp</span><br><span class="line">* of the returned watermark is smaller than that of the last emitted one, then no</span><br><span class="line">* new watermark will be generated.</span><br><span class="line">*</span><br><span class="line">* The interval in which this method is called and Watermarks are generated</span><br><span class="line">* depends on &#123;@link ExecutionConfig#getAutoWatermarkInterval()&#125;.</span><br><span class="line">*</span><br><span class="line">* @see org.Apache.flink.streaming.api.watermark.Watermark</span><br><span class="line">* @see ExecutionConfig#getAutoWatermarkInterval()</span><br><span class="line">*</span><br><span class="line">* @return &#123;@code Null&#125;, if no watermark should be emitted, or the next watermark to emit.</span><br><span class="line">*/</span><br><span class="line">@Nullable</span><br><span class="line">Watermark getCurrentWatermark();</span><br></pre></td></tr></table></figure>

<ul>
<li>Punctuated Watermarks - AssignerWithPunctuatedWatermarks </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public interface AssignerWithPunctuatedWatermarks&lt;T&gt; extends TimestampAssigner&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Asks this implementation if it wants to emit a watermark. This method is called right after</span><br><span class="line">* the &#123;@link #extractTimestamp(Object, long)&#125; method.</span><br><span class="line">*</span><br><span class="line">* The returned watermark will be emitted only if it is non-null and itsTimestamp</span><br><span class="line">* is larger than that of the previously emitted watermark (to preserve the contract of</span><br><span class="line">* ascending watermarks). If a null value is returned, or theTimestamp of the returned</span><br><span class="line">* watermark is smaller than that of the last emitted one, then no new watermark will</span><br><span class="line">* be generated.</span><br><span class="line">*</span><br><span class="line">* For an example how to use this method, see the documentation of</span><br><span class="line">* &#123;@link AssignerWithPunctuatedWatermarks this class&#125;.</span><br><span class="line">*</span><br><span class="line">* @return &#123;@code Null&#125;, if no watermark should be emitted, or the next watermark to emit.</span><br><span class="line">*/</span><br><span class="line">@Nullable</span><br><span class="line">Watermark checkAndGetNextWatermark(T lastElement, long extractedTimestamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AssignerWithPunctuatedWatermarks 继承了TimestampAssigner接口 -TimestampAssigner</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public interfaceTimestampAssigner&lt;T&gt; extends Function &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Assigns aTimestamp to an element, in milliseconds since the Epoch.</span><br><span class="line">*</span><br><span class="line">* The method is passed the previously assignedTimestamp of the element.</span><br><span class="line">* That previousTimestamp may have been assigned from a previous assigner,</span><br><span class="line">* by ingestionTime. If the element did not carry aTimestamp before, this value is</span><br><span class="line">* &#123;@code Long.MIN_VALUE&#125;.</span><br><span class="line">*</span><br><span class="line">* @param element The element that theTimestamp is wil be assigned to.</span><br><span class="line">* @param previousElementTimestamp The previous internalTimestamp of the element,</span><br><span class="line">* or a negative value, if noTimestamp has been assigned, yet.</span><br><span class="line">* @return The newTimestamp.</span><br><span class="line">*/</span><br><span class="line">long extractTimestamp(T element, long previousElementTimestamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从接口定义可以看出，Watermark可以在Event(Element)中提取EventTime，进而定义一定的计算逻辑产生Watermark的时间戳。</p>
<h4 id="Watermark解决EventTime问题"><a href="#Watermark解决EventTime问题" class="headerlink" title="Watermark解决EventTime问题"></a>Watermark解决EventTime问题</h4><p>从上面的Watermark生成接口和Apache Flink内部对Periodic Watermark的实现来看，Watermark的时间戳可以和Event中的EventTime 一致，也可以自己定义任何合理的逻辑使得Watermark的时间戳不等于Event中的EventTime，Event中的EventTime自产生那一刻起就不可以改变了，不受Apache Flink框架控制，而Watermark的产生是在Apache Flink的Source节点或实现的Watermark生成器计算产生(如上Apache Flink内置的 Periodic Watermark实现), Apache Flink内部对单流或多流的场景有统一的Watermark处理。</p>
<p>回过头来我们在看看Watermark机制如何解决上面的问题，上面的问题在于如何将迟来的EventTime 位11的元素正确处理。要解决这个问题我们还需要先了解一下EventTime window是如何触发的？ EventTime window 计算条件是当Window计算的Timer时间戳 小于等于 当前系统的Watermak的时间戳时候进行计算。 </p>
<ul>
<li>当Watermark的时间戳等于Event中携带的EventTime时候，上面场景（Watermark=EventTime)的计算结果如下：</li>
</ul>
<p><img src="/source/img/1586590446371.png" alt="1586590446371"></p>
<p> 上面对应的DDL(Alibaba 企业版的Flink分支)定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE source(</span><br><span class="line">...,</span><br><span class="line">Event_timeTimeStamp,</span><br><span class="line">WATERMARK wk1 FOR Event_time as withOffset(Event_time, 0) </span><br><span class="line">) with (</span><br><span class="line">...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果想正确处理迟来的数据可以定义Watermark生成策略为 Watermark = EventTime -5s， 如下：</li>
</ul>
<p><img src="/source/img/1586590568191.png" alt="1586590568191"></p>
<p>上面对应的DDL(Alibaba 内部的DDL语法，目前正在和社区讨论)定义如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE source(</span><br><span class="line">...,</span><br><span class="line">Event_timeTimeStamp,</span><br><span class="line">WATERMARK wk1 FOR Event_time as withOffset(Event_time, 5000) </span><br><span class="line">) with (</span><br><span class="line">...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面正确处理的根源是我们采取了 延迟触发 window 计算 的方式正确处理了 Late Event. 与此同时，我们发现window的延时触发计算，也导致了下游的LATENCY变大，本例子中下游得到window的结果就延迟了5s.</p>
<h4 id="多流的Watermark处理"><a href="#多流的Watermark处理" class="headerlink" title="多流的Watermark处理"></a>多流的Watermark处理</h4><p>在实际的流计算中往往一个job中会处理多个Source的数据，对Source的数据进行GroupBy分组，那么来自不同Source的相同key值会shuffle到同一个处理节点，并携带各自的Watermark，Apache Flink内部要保证Watermark要保持单调递增，多个Source的Watermark汇聚到一起时候可能不是单调自增的，这样的情况Apache Flink内部是如何处理的呢？如下图所示：</p>
<p><img src="/source/img/1586591065285.png" alt="1586591065285"></p>
<p>Apache Flink内部实现每一个边上只能有一个递增的Watermark， 当出现多流携带Eventtime汇聚到一起(GroupBy or Union)时候，Apache Flink会选择所有流入的Eventtime中最小的一个向下游流出。从而保证watermark的单调递增和保证数据的完整性.如下图: </p>
<p><img src="/source/img/1586591258097.png" alt="1586591258097"></p>
<p>本节以一个流计算常见的乱序问题介绍了Apache Flink如何利用Watermark机制来处理乱序问题. 本篇内容在一定程度上也体现了EventTime Window中的Trigger机制依赖了Watermark(后续Window篇章会介绍)。Watermark机制是流计算中处理乱序，正确处理Late Event的核心手段。</p>
<h4 id="使用Event-Time-处理实时数据"><a href="#使用Event-Time-处理实时数据" class="headerlink" title="使用Event Time 处理实时数据"></a>使用Event Time 处理实时数据</h4><blockquote>
<p>如下是一段 log 日志，我们根据该日志格式，来分析客户的下单量情况。</p>
<p>日志格式：<br>1581490623000,James,5<br>1581490624150,John,2<br>…
接下来，我们从并行Source 和 非并行Source 两个方向，来使用 EventTime 处理实时数据。(接下来示例，设置延迟为0s，即不延迟)</p>
</blockquote>
<h4 id="非并行Source"><a href="#非并行Source" class="headerlink" title="非并行Source"></a>非并行Source</h4><p>非并行Source，以 socketTextStream为例来介绍 Flink使用 EventTime 处理实时数据。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* TODO 非并行Source EventTime </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> liuzebiao</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span> 2020-2-12 15:25</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventTimeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置EventTime作为时间标准</span></span><br><span class="line">    env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读取source，并指定(1581490623000,Mary,3)中哪个字段为EventTime时间</span></span><br><span class="line">    <span class="comment">//WaterMarks:是Flink中窗口延迟触发的机制。Time.seconds(0)表示无延迟。</span></span><br><span class="line">    SingleOutputStreamOperator&lt;String&gt; source = env.socketTextStream(<span class="string">"localhost"</span>, <span class="number">8888</span>).assignTimestampsAndWatermarks(<span class="keyword">new</span> BoundedOutOfOrdernessTimestampExtractor&lt;String&gt;(Time.seconds(<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(String line)</span> </span>&#123;</span><br><span class="line">            String[] split = line.split(<span class="string">","</span>);</span><br><span class="line">            <span class="keyword">return</span> Long.parseLong(split[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; mapOperator = source.map(line -&gt; &#123;</span><br><span class="line">        String[] split = line.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">return</span> Tuple2.of(split[<span class="number">1</span>], Integer.parseInt(split[<span class="number">2</span>]));</span><br><span class="line">    &#125;).returns(Types.TUPLE(Types.STRING,Types.INT));</span><br><span class="line">    </span><br><span class="line">    KeyedStream&lt;Tuple2&lt;String, Integer&gt;, Tuple&gt; keyedStream = mapOperator.keyBy(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//EventTime滚动窗口</span></span><br><span class="line">    WindowedStream&lt;Tuple2&lt;String, Integer&gt;, Tuple, TimeWindow&gt; windowedStream = keyedStream.window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">5</span>)));</span><br><span class="line">    </span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; sum = windowedStream.sum(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    sum.print();</span><br><span class="line">    </span><br><span class="line">    env.execute(<span class="string">"EventTimeDemo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试结果</strong></p>
<p><img src="/source/img/1586583564019.png" alt="1586583564019"></p>
<blockquote>
<p><strong>结果分析</strong><br>备注： (1581490623000转换后为：2020-02-12 14:57:03<br>​             1581490624000转换后为：2020-02-12 14:57:04)</p>
<p>当我们在Socket中输入如下数据：<br>1581490623000,Mary,2<br>1581490624000,John,3<br>1581490624500,Clerk,1<br>1581490624998,Maria,4<br>1581490624999,Mary,3<br>1581490626000,Mary,3<br>1581490630800,Steve,3     (2020-02-12 14:57:10.800)</p>
<p>窗口定义的时间是：含头不含尾。即：[0,5)，<br>图片解析：(我们定义滚动窗口为5s，我们分析图片发现到4998时,并没有输出内容。因为4998还没超过5s，窗口规定是&gt;=临界值时触发，所以当我们输入4999临界时，我们发现输出内容了，说明一个窗口滚动完成，输出内容包含4999这个时间的值；当输入6000时，6000在[5,10)之间没有&gt;10，所以不输出。输入30800【2020-02-12 14:57:10.800)】，已经超过10s，所以结果只输出1个 (Mary,3)，因为Steve已经被分到另一个窗口了)</p>
<p>还有一个问题，就是：当输入到 4999 时，只是Mary这个分组满足5s这个条件，但是其它分组John，Clerk 等也同步输出结果了。显然这不符合逻辑。为什么会出现这种情况呢？是因为SocketStream 是非并行数据流，所以才会出现这样子的结果。(接下来我们就是用并行数据流KafkaSource来分析)</p>
</blockquote>
<h4 id="并行Source"><a href="#并行Source" class="headerlink" title="并行Source"></a>并行Source</h4><p>并行Source，以 KafkaSouce 为例来介绍 Flink使用 EventTime 处理实时数据。</p>
<p><strong>代码</strong></p>
<p>并行KafkaSource EventTime示例(读取 topic为 window_demo中的消息)，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* TODO 并行KafkaSource EventTime示例(读取 topic为 window_demo中的消息)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> liuzebiao</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span> 2020-2-12 15:25</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventTimeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置EventTime作为时间标准</span></span><br><span class="line">        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Kafka props</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//指定Kafka的Broker地址</span></span><br><span class="line">        properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"192.168.204.210:9092,192.168.204.211:9092,192.168.204.212:9092"</span>);</span><br><span class="line">        <span class="comment">//指定组ID</span></span><br><span class="line">        properties.put(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">"flinkDemoGroup"</span>);</span><br><span class="line">        <span class="comment">//如果没有记录偏移量，第一次从最开始消费</span></span><br><span class="line">        properties.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, <span class="string">"earliest"</span>);</span><br><span class="line">        </span><br><span class="line">        FlinkKafkaConsumer&lt;String&gt; kafkaSource = <span class="keyword">new</span> FlinkKafkaConsumer(<span class="string">"window_demo"</span>, <span class="keyword">new</span> SimpleStringSchema(), properties);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.通过addSource()方式，创建 Kafka DataStream</span></span><br><span class="line">        <span class="comment">//读取source，并指定(1581490623000,Mary,3)中哪个字段为EventTime时间</span></span><br><span class="line">        SingleOutputStreamOperator&lt;String&gt; source = env.addSource(kafkaSource).assignTimestampsAndWatermarks(<span class="keyword">new</span> BoundedOutOfOrdernessTimestampExtractor&lt;String&gt;(Time.seconds(<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(String line)</span> </span>&#123;</span><br><span class="line">                String[] split = line.split(<span class="string">","</span>);</span><br><span class="line">                <span class="keyword">return</span> Long.parseLong(split[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; mapOperator = source.map(line -&gt; &#123;</span><br><span class="line">            String[] split = line.split(<span class="string">","</span>);</span><br><span class="line">            <span class="keyword">return</span> Tuple2.of(split[<span class="number">1</span>], Integer.parseInt(split[<span class="number">2</span>]));</span><br><span class="line">        &#125;).returns(Types.TUPLE(Types.STRING,Types.INT));</span><br><span class="line">        </span><br><span class="line">        KeyedStream&lt;Tuple2&lt;String, Integer&gt;, Tuple&gt; keyedStream = mapOperator.keyBy(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//EventTime滚动窗口</span></span><br><span class="line">        WindowedStream&lt;Tuple2&lt;String, Integer&gt;, Tuple, TimeWindow&gt; windowedStream = keyedStream.window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">5</span>)));</span><br><span class="line">        </span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; sum = windowedStream.sum(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        sum.print();</span><br><span class="line">        </span><br><span class="line">        env.execute(<span class="string">"EventTimeDemo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试结果</strong></p>
<ol>
<li><p>创建 Topic 命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper 192.168.204.210:2181,192.168.204.211:2181,192.168.204.212:2181 --replication-factor 1 --partitions 3 --topic window_demo</span><br><span class="line"><span class="meta">#</span> (特别注意一下：此处创建了3个分区)</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 Topic 成功截图(点击放大查看)：</p>
<p><img src="/source/img/1586583578404.png" alt="1586583578404"></p>
</li>
<li><p>使用命令，写入数据到Kafka：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list 192.168.204.210:9092 --topic window_demo</span><br></pre></td></tr></table></figure>

<p>使用命令写入以下数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1581490623000,Mary,2</span><br><span class="line">1581490624000,John,3</span><br><span class="line">1581490624500,Clerk,1</span><br><span class="line">1581490624998,Maria,4</span><br><span class="line">1581490624999,Mary,3</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试结果：</p>
<p><img src="/source/img/1586583590046.png" alt="1586583590046"></p>
</li>
</ol>
<h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h4><p>​    在并行Source一例中，当我们输入1581490624999,Mary,3时，我们看到控制台会直接帮我们输出计算结果。</p>
<p>​    但是，在使用 KafkaSource 时，我们连续输入了 3次1581490624999,Mary,3，我们才看到控制台帮我们输出计算了结果。</p>
<p>​    那这是为什么呢？这是 并行Source 和 非并行Source 的原因导致的（这里涉及到 KafkaSource 创建的 topic，有 3 个分区的原因，如下图所示）</p>
<p><img src="/source/img/1586584999171.png" alt="1586584999171"></p>

      
    </div>

    
      


    

    
    
    

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/images/weixin.jpg" alt="刘小恺(Kyle) wechat" style="width: 200px; max-width: 100%;">
    <div>如有疑问可联系博主</div>
</div>

      </div>
    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/总结/" rel="tag"><i class="fa fa-tag"></i> 总结</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div class="social_share">
            
            
               <div id="needsharebutton-postbottom">
                 <span class="btn">
                    <i class="fa fa-share-alt" aria-hidden="true"></i>
                 </span>
               </div>
            
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/28/21.总结/Spark/" rel="next" title="Spark 总结">
                <i class="fa fa-chevron-left"></i> Spark 总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/05/07/21.总结/Redis/" rel="prev" title="Redis">
                Redis <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="刘小恺(Kyle)">
            
              <p class="site-author-name" itemprop="name">刘小恺(Kyle)</p>
              <p class="site-description motion-element" itemprop="description">Python 、Machine learning 、Docker k8s  crawler 、Golang 、Web</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">277</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">70</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">76</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/KyleAdultHub" target="_blank" title="GitHub" rel="external nofollow"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:liukaijian45@163.com" target="_blank" title="E-Mail" rel="external nofollow"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink组件栈"><span class="nav-text">Flink组件栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#API-amp-Libraries-层"><span class="nav-text">API &amp; Libraries 层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Runtime-核心层"><span class="nav-text">Runtime 核心层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#物理部署层"><span class="nav-text">物理部署层</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-分层-API"><span class="nav-text">Flink 分层 API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL-amp-Table-API"><span class="nav-text">SQL &amp; Table API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DataStream-amp-DataSet-API"><span class="nav-text">DataStream &amp; DataSet API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Stateful-Stream-Processing"><span class="nav-text">Stateful Stream Processing</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-集群架构"><span class="nav-text">Flink 集群架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#核心组件"><span class="nav-text">核心组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task-amp-SubTask"><span class="nav-text">Task &amp; SubTask</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#资源管理"><span class="nav-text">资源管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-优势"><span class="nav-text">Flink 优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Source-和-sink"><span class="nav-text">Source 和 sink</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义-Data-Source"><span class="nav-text">自定义 Data Source</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ParallelSourceFunction-和-RichParallelSourceFunction"><span class="nav-text">ParallelSourceFunction 和 RichParallelSourceFunction</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义-Sink"><span class="nav-text">自定义 Sink</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#导入依赖"><span class="nav-text">导入依赖</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#自定义-Sink-1"><span class="nav-text">自定义 Sink</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用自定义-Sink"><span class="nav-text">使用自定义 Sink</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Streaming-Connectors"><span class="nav-text">Streaming Connectors</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#内置连接器"><span class="nav-text">内置连接器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flink-状态"><span class="nav-text">Flink 状态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#算子状态"><span class="nav-text">算子状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#键控状态"><span class="nav-text">键控状态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#检查点机制"><span class="nav-text">检查点机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#checkpoint"><span class="nav-text">checkpoint</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#开启检查点"><span class="nav-text">开启检查点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#窗口函数"><span class="nav-text">窗口函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Tumbling-Windows"><span class="nav-text">Tumbling Windows</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sliding-Windows"><span class="nav-text">Sliding Windows</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Session-Windows"><span class="nav-text">Session Windows</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Global-Windows"><span class="nav-text">Global Windows</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Count-Windows"><span class="nav-text">Count Windows</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时间（Time）"><span class="nav-text">时间（Time）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#时间类型"><span class="nav-text">时间类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间详解"><span class="nav-text">时间详解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间乱序存在的问题"><span class="nav-text">时间乱序存在的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是Watermark"><span class="nav-text">什么是Watermark</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Watermark的产生方式"><span class="nav-text">Watermark的产生方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Watermark的接口定义"><span class="nav-text">Watermark的接口定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Watermark解决EventTime问题"><span class="nav-text">Watermark解决EventTime问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多流的Watermark处理"><span class="nav-text">多流的Watermark处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用Event-Time-处理实时数据"><span class="nav-text">使用Event Time 处理实时数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非并行Source"><span class="nav-text">非并行Source</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并行Source"><span class="nav-text">并行Source</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结果分析"><span class="nav-text">结果分析</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘小恺(Kyle)</span>

  

  
</div>


  










        








        
      </div>
    </footer>

    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  











  



  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/reading_progress/reading_progress.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  








  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  
  
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(function (item) {
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'V62wzdGpgPV7y1tPnu1v1KYX-gzGzoHsz',
        appKey: 'SkJs3cwXAUsdgr6BkxmW2ctm',
        placeholder: '客观(*╹▽╹*)，请留下您的宝贵意见...   \n 请用浏览器打开进行评论, 在微信或其他客户端可能导致作者收不到提醒 \n 信息栏作用:\n 昵称: 在评论中显示的昵称 \n 邮箱: 可以在收到您评论的回复后通知到您邮箱 \n 网址: 评论需要跳转链接可填写, 将可以通过点击您评论中的昵称进行跳转 \n',
        avatar:'monsterid',
        meta:guest,
        pageSize:'10' || 10,
        visitor: false
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('100');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  


  
  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "bottomCenter";
      
          pbOptions.networks = "Wechat,Weibo,QQZone";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
      flOptions = {};
      
          flOptions.iconStyle = "box";
      
          flOptions.boxForm = "horizontal";
      
          flOptions.position = "middleRight";
      
          flOptions.networks = "Wechat,Weibo,QQZone";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script>

  

  

  

  

  

  

  
</body>
</html>
